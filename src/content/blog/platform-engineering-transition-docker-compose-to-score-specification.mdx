---
heroImage: /src/assets/images/Terraform.png
category: 'Platform Engineering'
description: >-
  A comprehensive guide for platform engineers on how to transition from using Docker Compose to Score Specification.
pubDate: 2024-09-04
draft: true
tags:
  - devops
  - platformengineering
  - score
  - dockercompose
title: >-
  From Docker Compose to Score: A Platform Engineering Guide
---

Welcome! So, you’ve been noticing Platform Engineering everywhere, along with terminology like Internal Developer Platform, Internal Developer Portal (IDP) and the idea of graph based backend instead of pipelines. It’s like discovering design patterns for the first time or hearing about a new frontend framework — you can’t wait to implement at the first opportunity. But where should you start?

Let's set some base context about the background I am coming from:

- All applications are containerized and deployed to a Kubernetes cluster.
- Developers are currently using Docker Compose or Helm (with some intercept technology) to develop locally. Some requiring a container registry and others building all the required images locally.
- Applications are deployed via pipelines or GitOps approach.
- Infrastructure is managed via Terraform.

For the most part everything is there but you are still far away from providing self service and an amazing developer experience (DevEx).

I decided one of the first places to dive into was the Score specification to standardise a specification for developers to use while allowing it to be platform agnostic (it can be deployed anywhere).

This post shows how you can transition from using Docker Compose to the Score Specification. Once transitioned, you can use score to generate a deployment mode in Docker Compose or any other supported deploy mode.

# What is Score?

[Score](https://score.dev/) is a developer-focused, platform-independent specification (YAML file) for managing workloads. It helps maintain consistent configuration across both local and remote environments. In Score you define workloads (you can map this workload concept to that of a Pod in Kubernetes) and other top-level reference definitions like containers, service and resources.

Score has different implementations (CLI's), i.e. what platform specific configuration files can be generated, like Kubernetes, Docker Compose etc. You could define a Score file and then decide what platform you want to run it on. Since we are targeting Docker Compose, the relevant implementation is [score-compose](https://docs.score.dev/docs/score-implementation/score-compose/).

The [score documentation site](https://docs.score.dev/docs/) does a great job at explaining everything so please head there for a deep dive.

# Our Example application

The application we will use is a standard, box - box - cylinder... Frontend, Backend and Database. The technology used is NextJs, .NET and Microsoft SQL Server. See this repository for the [source](). This is not production ready source - it is only a sample for this demo of score.

## Docker Compose File

The docker compose file is quite simple for the three components, though I would highlight these aspects of it:

- Build is used as this is for local development. The images can be rebuilt after any changes and there is no reliance needed on a container registry.
- Ports exposed to the host as developers might want to connect to the database to debug issues as an example.

```yaml
name: manually-created
services:
  backend:
    build:
      context: ./backend
    environment:
      ASPNETCORE_ENVIRONMENT: UAT
    depends_on:
      - db
    ports:
      - target: 8080
        published: '8082'

  frontend:
    build:
      context: ./frontend
    environment:
      ENVIRONMENT: UAT
    depends_on:
      - backend
    ports:
      - target: 3000
        published: '3233'

  db:
    image: mcr.microsoft.com/mssql/server:2022-latest
    env_file:
      - ./backend/.env
    ports:
      - target: 1433
        published: '1433'
```

# Defining the Score Specification

From our application we decide to have the following files defining our workloads:

- score-frontend.yaml
- score-backend.yaml
- score-database.yaml

## Score Frontend File

```yaml
apiVersion: score.dev/v1b1

metadata:
  name: frontend

service:
  ports:
    frontend:
      port: 3233
      targetPort: 3000

containers:
  frontend:
    image: ./frontend
    variables:
      ENVIRONMENT: UAT
```

## Score Backend File

```yaml
apiVersion: score.dev/v1b1

metadata:
  name: backend

service:
  ports:
    backend:
      port: 8082
      targetPort: 8080

containers:
  backend:
    image: ./backend
    variables:
      ASPNETCORE_ENVIRONMENT: UAT
```

## Score Database File

```yaml
apiVersion: score.dev/v1b1

metadata:
  name: database

service:
  ports:
    database:
      port: 1433
      targetPort: 1433

containers:
  database:
    image: mcr.microsoft.com/mssql/server:2022-latest
    variables:
      ENVIRONMENT: UAT
```

# Generate Docker Compose file with score-compose

You would need to follow the [instructions](https://docs.score.dev/docs/score-implementation/score-compose/#installation) to install score-compose first and assuming necessary Docker is installed.

## Initialize

Once installed, initialize score-compose:

```bash
score-compose init --no-sample
```

The flag '--no-sample' ensures init does not create a default score.yaml file as we have our files defined already.

## Generate

Run generate on for each workload:

```bash
score-compose generate score-frontend.yaml --build=frontend=./aspnetcore -o score-compose.yaml
score-compose generate score-backend.yaml --build=backend=./backend -o score-compose.yaml
score-compose generate score-database.yaml -o score-compose.yaml
```

Important to note here, is that generate is accumulative, so any additional runs will just add to the current generated state. The reason for multiple generates is currently the --build parameter is yet to support workload context (it is coming soon though).
Parameters dive in:

- '--build' : Specifies an optional build context to use for the given container. The format is either --build=container=./dir or --build=container=\{'"context":"./dir"\}. This is an important one for development as it allows the image to be built when running docker compose up, unlike the database where we are using an existing image.
- '-o' : Specifies the output file to write the composed Docker Compose file to. By default, the output file is named compose.yaml.

We run one last generate to expose ports to the host:

```bash
score-compose generate score-database.yaml --publish 8002:backend:8002 --publish 5348:frontend:5348 --publish 1433:database:1433 -o score-compose.yaml
```

Parameters dive in:

- '--publish' : The ports defined are no reacheable on the docker host. To allow this the --publish flag enables this using the form HOST_PORT:\<workload name\>:CONTAINER_PORT. The container port is any port you want to map to the host.

## Generated Docker-Compose file

The resultant file looks mostly like the one that was manually created:

```yaml
name: src
services:
  backend-backend:
    annotations:
      compose.score.dev/workload-name: backend
    build:
      context: ./backend
    environment:
      ENVIRONMENT: UAT
    hostname: backend
    ports:
      - target: 8002
        published: '8002'
  database-database:
    annotations:
      compose.score.dev/workload-name: database
    environment:
      ENVIRONMENT: UAT
    hostname: database
    image: mcr.microsoft.com/mssql/server:2022-latest
    ports:
      - target: 1433
        published: '1433'
  frontend-frontend:
    annotations:
      compose.score.dev/workload-name: frontend
    environment:
      ENVIRONMENT: UAT
    hostname: frontend
    image: ./frontend
    ports:
      - target: 5348
        published: '5348'
```

The naming convention with the services is 'workloadName-containerName' so you could adjust it if you dont like this convention.

# Docker-compose up

To get up and running, we execute docker-compose up specifying our generated file:

```bash
docker-compose -f score-compose.yaml up
```

You should have your application running as before. The only aspect I havent dug into is the depends property but I will update as soon as I do.

# Conclusion

As with learning the specification to define a docker compose file, the score specification is quite simple and easy to adopt. We have covered a simple example application and created score files to represent our workloads. You could install a different implementation, like score-k8s and generate manifest files to deploy this into a Kubernetes cluster. I hope this introduction gave a good insight into the possibilities, would you consider transitioning to use Score?
